import {  BadRequestException,  Injectable,  NotFoundException,} from '@nestjs/common';import { CreateAppointmentRequestDto } from './dto/create.dto';import { PrismaService } from '../prisma/prisma.service';@Injectable()export class AppointmentRequestService {  constructor(private readonly prisma: PrismaService) {}  async create(data: CreateAppointmentRequestDto) {    const { appointment_time, ...rest } = data;    if (data.doctor_id) {      const doctor = await this.prisma.doctor.findUnique({        where: { user_id: data.doctor_id },      });      if (!doctor) {        throw new NotFoundException('Bác sĩ không tồn tại');      }    }    const service = await this.prisma.clinicService.findUnique({      where: { id: data.service_id },    });    if (!service) {      throw new NotFoundException('Dịch vụ không tồn tại');    }    const patient = await this.prisma.patient.findUnique({      where: { user_id: data.patient_id },    });    if (!patient) {      throw new NotFoundException('Bệnh nhân không tồn tại');    }    try {      const appointment = await this.prisma.appointmentRequest.create({        data: {          ...rest,          appointment_time: appointment_time,        },      });      const patient = await this.prisma.patient.findUnique({        where: { user_id: data.patient_id },        select: { full_name: true, phone_number: true },      });      const updateData: Partial<{ full_name: string; phone_number: string }> =        {};      if (!patient?.full_name && data.full_name)        updateData.full_name = data.full_name;      if (!patient?.phone_number && data.phone_number)        updateData.phone_number = data.phone_number;      await this.prisma.patient.update({        where: { user_id: data.patient_id },        data: updateData,      });      return {        message: 'Đặt lịch thành công',        appointment,      };    } catch (error) {      throw new BadRequestException('Đặt lịch bị lỗi!', { cause: error });    }  }  async cancel(appointmentId: string) {    const appointment = await this.prisma.appointmentRequest.findUnique({      where: { id: appointmentId },    });    if (!appointment) {      throw new NotFoundException('Không tìm thấy lịch hẹn!');    }    try {      await this.prisma.appointmentRequest.update({        where: { id: appointmentId },        data: { status: 'CANCELLED' },      });      return {        message: 'Hủy lịch thành công',      };    } catch (error) {      throw new BadRequestException('Hủy lịch bị lỗi!', { cause: error });    }  }  async findAllOfPatient(id: string) {    const user = await this.prisma.account.findUnique({      where: { id },    });    if (!user) {      throw new BadRequestException('Người dùng không tồn tại');    }    return this.prisma.appointmentRequest.findMany({      where: { patient_id: user.id },      orderBy: {        created_at: 'desc',      },    });  }  private getStartEndDate(dateIso: string) {    const date = new Date(dateIso);    const startOfDay = new Date(date);    startOfDay.setUTCHours(0, 0, 0, 0);    const endOfDay = new Date(date);    endOfDay.setUTCHours(23, 59, 59, 999);    return {      startOfDay,      endOfDay,    };  }  async findAllByDate(dateIso: string) {    const { startOfDay, endOfDay } = this.getStartEndDate(dateIso);    return this.prisma.appointmentRequest.findMany({      where: {        appointment_time: {          gte: startOfDay,          lte: endOfDay,        },      },      orderBy: {        created_at: 'desc',      },    });  }  async findAllByService(id: string, dateIso: string) {    const service = await this.prisma.clinicService.findUnique({      where: { id },    });    if (!service) {      throw new BadRequestException('Dịch vụ không tồn tại');    }    const { startOfDay, endOfDay } = this.getStartEndDate(dateIso);    return this.prisma.appointmentRequest.findMany({      where: {        service_id: id,        appointment_time: {          gte: startOfDay,          lte: endOfDay,        },      },      orderBy: {        created_at: 'desc',      },    });  }}