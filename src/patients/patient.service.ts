import { BadRequestException, Injectable } from '@nestjs/common';import { PrismaService } from '../prisma/prisma.service';import { UpdatePatientDto } from './dto/update-patient.dto';@Injectable()export class PatientService {  constructor(private readonly prisma: PrismaService) {}  async findOne(id: string) {    return this.prisma.patient.findUnique({      where: { user_id: id },      include: {        user: {          select: {            email: true,          },        },      },    });  }  async findAll() {    return this.prisma.patient.findMany({      include: {        user: {          select: {            email: true,            is_active: true,          },        },      },      orderBy: {        full_name: 'asc',      },    });  }  async update(id: string, payload: UpdatePatientDto) {    const patient = await this.prisma.patient.findUnique({      where: { user_id: id },    });    if (!patient) {      throw new BadRequestException('B·ªánh nh√¢n kh√¥ng t·ªìn t·∫°i');    }    // üîç Ki·ªÉm tra payload c√≥ field h·ª£p l·ªá hay kh√¥ng    const hasData = Object.values(payload).some(      (value) => value !== undefined && value !== null && value !== '',    );    if (!hasData) {      throw new BadRequestException('Kh√¥ng c√≥ d·ªØ li·ªáu n√†o ƒë·ªÉ c·∫≠p nh·∫≠t');    }    try {      await this.prisma.patient.update({        where: { user_id: id },        data: payload,      });    } catch {      throw new BadRequestException('C·∫≠p nh·∫≠t th√¥ng tin b·ªánh nh√¢n th·∫•t b·∫°i');    }    return { message: 'C·∫≠p nh·∫≠t th√¥ng tin b·ªánh nh√¢n th√†nh c√¥ng' };  }}